
----------------------------------------------------------------------

BU.HLP 1.11		Copyright(C)1989-95 by Yohei Shimizu
	(TAB size=8)
----------------------------------------------------------------------

使用法:
	BU [-w] [-e[STR]] [-n[NAME]] [-r] コマンド .... [パラメータ...]

      各コマンド実行後 ERRORLEVEL に Ret の数値を返します.
      なお ERRORLEVEL には 255 までしか値が返りませんが -e では 65536
    までの数を扱う事ができます.

      コマンドは他のコマンドと区別がつく任意の位置で省略可能です. 但し
    バッチファイル中等での使用時にはバージョンアップで似たようなコマン
    ドが増える可能性があるのでなるべく省略しないでください.

	省略例)DSPERRORLEVEL → DSPERR


スイッチ:
      スイッチの文字は英大, 小文字可. コマンドの前に "-" か "/" で指定
    してください. スイッチとスイッチの間はスペースを空けてください.

 *	-w
	  環境変数の大小文字を区別して処理

	  通常はすべての環境変数は大文字で格納されていると仮定して
	  処理を行ないますので, 小文字の環境変数は処理ができませんが,
	  このオプションを指定すると, 小文字の環境変数も検索できます.
	  なお, このオプション指定時は, 環境変数の指定自身の大小文字も
	  区別されます.

	  例)BU -w -nDIR printf \%%windir%%

	  -n で小文字の環境変数に設定を行なう場合は -w を -n より前に
	  指定してください.

	  例)BU -w -nwindir printf \%%windir%%\system

	  -w は printf 以外のバッチ自身で展開されるものには, 適用され
	  ない事に注意してください. 例えば BU -w STRLEN %windir% とし
	  てもバッチ自身での展開により, 大文字の WINDIR が適用されます.


 *	-e[STR]
	  コマンド実行後のリターン値(ERRORLEVEL)を標準出力表示

	  STRを指定すれば数値の前に文字を表示します.

	  例)BU -eマシンコードは MACHINE


 *	-n[NAME],-d[NAME]	(NAMEのデフォルトは ENVTMP)
          コマンド実行後の標準出力を環境変数に代入

	  NAMEを指定すれば任意の環境変数に代入できます. NAMEを指定せずに
	  -nだけを指定時は ENVTMP という名前の環境変数に代入されます.
	  キー入力のコマンドでは入力文字が代入されます(-e 時はretを代入)

	  例)BU -nCDIR CURDRVPATH   (カレントドライブ:パスを CDIRに代入)
	     BU -e -nMCODE MACHINE  (MACHINEの戻り値を MCODEに代入)

	 なお環境変数への代入は最大512文字です. -nも-dも同じ意味です.


 *	-r
	  環境変数の参照を現在の一番上のプロセスにする

	  V1.07以前のバージョンではこの動作がデフォルトの指定でしたが
	  現在のバージョンではこのオプション指定が必要です.
	  このオプション指定時には, 環境変数の参照で使用する領域をメモリ
	  上の最下位のCOMMAND.COMから取得します. 

	  なおBATCPで-bを使用して.COM内にBU.COMを取り込んだ場合はこの-r
	  の動作がデフォルトとなります.


 *	-m,-c	(以前との互換の及びBATCPとの連携のために用意)
	  環境変数の参照を現在の親プロセスにする

	  現在はこの指定は不要です. 以前のバージョンとの互換のために置い
	  てあります. 以前のバージョンではこの指定がなければルートの環境
	  変数を参照しました(-rの動作)が, 現在はこのオプションを指定しな
	  くても親プロセスの環境変数の領域を参照します.

	  なおBATCPで取り込んだ場合は-rの動作がデフォルトとなりますので
	  現在の環境変数を取り扱いたい場合はこのオプションを指定してくだ
	  さい. その場合BATCPとの環境変数の連携がうまく行かないことに注
	  意してください. 通常は -m(-c),および-rのオプションは特に指定す
	  る必要はありません.

----------------------------------------------------------------------

 *	数値の指定
	  各コマンド内で使用する数値としては以下のものが使用できます.
		1234		: 符号なし10進数(0〜65535)
		0x1234		: 符号なし16進数(0〜FFFF)
		ENV_NAME	: 環境変数自身
				  (%ENV_NAME%とするのと同じ)
		ERRORLEVEL	: 直前のERRORLEVELの値
		12+56		: 簡単な計算式
			(CALCコマンドで使用できる形式の計算式)
	  例)BU LINPUTFILE BU.HLP 9+10
	     BU LINPUTFILE BU.HLP ENVTMP*(2+ERRORLEVEL)
	     BU LINPUTFILE BU.HLP ERRORLEVEL+0x100

 *	バイト数の換算
	1キロバイト=1024バイト で計算しています.
	1メガバイト=1024キロバイト(1048576バイト) で計算しています.

 *	""で文字列をくくる事により文字列に空白を含める事ができます
	  例)BU STRMID "Hello World!" 5 5
	後半の"の直後に文字がある場合はそこで文字列が終わりとはみなしません,
	例えば BU PRINTF "ABC"DEF" では ABC"DEF が文字列として扱われます.
	"自身の指定には \" を使ってください.

 *	ECHOなどの表示メッセージには以下のコントロールコード命令が使えます.
 *	$の後に $,*,英字,数字,[,\,],^,_ を続けて指定してください.
	  $$	: $ 自身を表示
	  $英字 : 対応するコントロールコードを表示(例:$J=[LF],$[=[ESC],
		 $M=改行動作(CR+LF) $*=キャリッジリターン(CR) $}='>' ${='<')
	  $数字 : 画面表示色を変更(ESC[3?mと同じ動作をする)
		($0:黒 $1:赤色 $2:緑 $3:黄 $4:青 $5:紫 $6:水色 $7:白)
	なおECHOなどの表示メッセージはダブルクォーテーション("")でくくって
	も無視されます("も画面に表示されます).

 *	!をコマンド名の前に付けるとコマンドの処理終了後改行を行います.
	  例)BU !KEYNUM 数字で選択してください:

----------------------------------------------------------------------

コマンド:
	[]付きのものは省略可能です.

	コマンドの前には * または ! が書かれていますが, これはHELP表示の
	キーワード検索用です. コマンドの前が * のものはすべてのDOSで動作
	します. コマンドの前が ! のものは以下の機種のみ動作可能です.
	 o FUJITSU FM16B/FMR or PANACOM CVM
	 o NEC PC98シリーズ(除くLT) or EPSON PC
	 o IBM PC/AT互換機,J-3100,AX

 *	? [キーワード]
 *	HELP [キーワード]
	  使用方法表示
	  キーワードを指定すれば前方一致で検索し一致したものすべてを表示
	  します. なおBU.HLPファイルがBU.COMと同じドライブ/パス(MS-DOS
	  V2.11ではカレントドライブ/パス)に必要です.
		Ret=	  0
	  例)BU ? KEY		(KEYで始まるコマンドを表示)
	     BU HELP -		(スイッチの使用法を表示)

 *	CALC 計算式
	  環境変数を数値変数とみなして計算をする(数値は65535まで)
	  変数には環境変数または数値を使用できます. 計算した答をERRORLEVEL
	  に返します. ERRORLEVELとしては254以内しか返せませんが, 環境変数な
	  どへのセットは65535まで可能です.
	  オーバーフロー等は考慮せずに16BITで単純計算を行っています. 例え
	  ば(0-2)を行うと65534が計算値になります.
		サポートする演算子は以下のものです.
								(優先順位)
		  変数		: 環境変数自体の値
		  ()		: 括弧(先に演算)		1
		  変数++	: 環境変数に1加える		2
		  変数--	: 環境変数を1減ずる		2
		  *		: 乗算(掛け算)			3
		  /		: 剰算(割り算)			3
		  %		: 剰余(割り算をした余り)	3
		  +		: 加算(足し算)			4
		  -		: 減算(引き算)			4
		  &		: AND				5
		  $		: OR				5
		  ^		: XOR				5
	  式は複数を混ぜ合わせて使用できますが, 演算子は優先順位を持って
	  おり優先順位の高いもの(上記数値の小さいもの)ほど優先度が高く先
	  に計算されます.
		Ret= 0〜253 : 環境変数の値または計算値
			254 : 環境変数の値または計算値が254以上
			255 : 数値が大きすぎる/変数がない/変数が数値と違う
	  例)BU CALC ENVTMP--
	     BU -e -nENVANS CALC ENVRET/10  (ENVRETを10で割りENVANSに入れる)
	     BU -e -nENVANS CALC 2*ENVBAR+20*(ENVFOO+2)

 *	RANDOM [n [,i]]
	  乱数を発生させる
	  nを超えない乱数を発生させます. n=0〜65535(省略時は10)
	  iを指定すると乱数の系列を変更します. i=0〜65535(省略時は0)
	  秒を元にした乱数を発生します. iを指定すると秒数だけではなくその
	  値も元にして発生させます.
	  iを指定しなければ同じ秒数内では同じ乱数値が返されますが, iに違
	  った値を指定して実行することにより違う値を求めることができます.
		Ret= 0〜n-1 : 乱数(255以上のときはERRORLEVELには255が返ります)
	  例)BU RANDOM 20
	     BU RANDOM 200,20

 *	CLOCKYEAR       (年の下２桁)
 *	CLOCKMONTH      (月)
 *	CLOCKDAY        (日)
 *	CLOCKWEEK       (曜日,0=日 1=月 .. 6=土)
 *	CLOCKHOUR       (時)
 *	CLOCKMINUTE     (分)
 *	CLOCKSECOND     (秒)
	  日時を得る
		Ret=	得た数値

 *	ECHO [表示メッセージ]
	  文字列を標準出力する
	 色の変更やコントロールコードの表示などが通常の ECHO より楽にな
	 ります.
		Ret=	  0
	  例)BU ECHO $6ドライブに$5$Mフロッピィ$6をセットして

 *	PRINTF format-string,[argument..]
	  C言語のprintf()感覚で文字列を標準出力
		Ret=	  0
	  format-stringの%指定は以下の書式です.
		%[flags][[0]width][.precision][F|N|h|l]type
	△	  flags		出力表示の設定
			-		変換結果を左寄せにする
	×		+		符号を付ける
	×		空白		符号に応じて空白か+を付ける
		  width		出力文字の最小桁数(少なくともこの桁数で表示)
			先頭に0を付けると余った桁には'0'が埋められる
		  .precision	最大表示文字数(最大がこの桁数にまるめられる)
	×	  F|N|h|l	未サポート
	△	  type	d : 10進整数	(符号なし short,0〜65535)
	△		i : 10進整数	(符号なし short,0〜65535)
			u : 10進整数	(符号なし short,0〜65535)
			o : 8進整数	(符号なし short,0〜65535)
			x : 16進数整数	(符号なし short,0〜65535,小文字)
			X : 16進数整数	(符号なし short,0〜65535,大文字)
	×		f : 10進数実数	(符号付き浮動小数点)
	×		e : 10進数実数	(符号付き浮動小数点 d.ddd e[sign] ddd)
	×		E : 10進数実数	(符号付き浮動小数点 d.ddd E[sign] ddd)
	×		g : 10進数実数	(fまたはe)
	×		G : 10進数実数	(fまたはE)
	△		c : 文字	(1文字 short,0〜65535,ASCIIまたは漢字)
	△		s : 文字列	(コマンドで表示される文字列を取り込む)
	×		n : ポインタ	(文字数をポインタに代入)
	×		p : farポインタ	(farアドレスを表示する)
	  format-stringには以下のエスケープシーケンスが使用できます.
		\a	ベル(07h)
		\b	バックスペース(08h)
		\e	エスケープ(1bh)
		\f	フォームフィード(0ch)
		\n	ラインフィード(0ah)
		\r	キャリッジリターン(0dh)
		\t	タブ(09h)
		\v	バーチカルタブ(0bh)
		\\	'\' 自身
		\"	'"' 自身(ダブルクォーテーション)
		\DDD	3桁までの8進コード1文字(ASCII)
		\xNNNN	4桁までの16進コード1文字(ASCII,漢字)
	△	\%NAME%	環境変数
	  argumentには以下のものが使えます.
	△	123		:10進数整数	(符号なし short)
		0x123f		:16進数整数	
		環境変数	:数値文字列が入っている環境変数
		ERRORLEVEL	:直前のERRORLEVELの値
		計算式		:CALCコマンドで使える形式の計算式
		"文字列"	:文字列自身(%s指定で有効)
	△	コマンド名	:BU内部コマンド
		  BU内部コマンドはコマンド自身にパラメーターが必要でないコマ
		  ンドのみ使用可能で以下のtype指定の時に値を取り込みます.
			%d,%i,%u,%x,%X,%c,%o	: RETに返った値を引数とする
			%s			: 表示する文字列を引数とする
		  なおパラメータが必要なBU内部コマンドについては括弧付きでパ
		  ラメータを指定する事によりパラメータの使用が可能になります.
		  例えば "LABEL A:" を実行するには "LABEL(A:)" とします.
	※ 注意:×がついているものは現在未サポート
		△がついているものはC言語のものと仕様が違う
	    ※	%はバッチファイル中では重ねて指定する必要があるので注意
		してください(%d->%%d)
	  例)BU PRINTF この機械は%%X号機です.\n,ID_CODE-100
	     BU PRINTF "今日は %%d月 %%d日です.\n",clockmonth,clockday
	     BU PRINTF "\a空きメモリは %%sキロバイトです.\n",DSPMEMFREE
	     BU -nFNAME PRINTF FILE%%02d%%02d.DAT,clockmonth,clockday
			→2月3日なら FILE0203.DAT を FNAME に代入
	     BU PRINTF "ドライブA:のラベルは%%s",LABEL(A:)

 *	DSPDATE		(形式 "YY/MM/DD")
 *	DSPTIME		(形式 "HH:MM:SS")
 *	DSPCLOCK	(形式 "YY/MM/DD HH:MM:SS")
	  時刻を表示
		Ret=	0
	  例)BU DSPDATE			→2001年10月1日なら 01/10/01 を表示
	     BU -nTSTR DSPTIME		→14時01分20秒なら 14:01:20 を代入

 *	KEYWAIT n ｺﾏﾝﾄﾞ [ﾊﾟﾗﾒｰﾀ]
	  キー入力を待つ秒数を指定する(n=0〜65535)
	  キー入力ｺﾏﾝﾄﾞ(KEYNUM,KEYYESNO,KEYRETSPC)の前に記述し指定した秒数だけ
	  入力を待つ
		Ret= 0〜253 : キー入力ｺﾏﾝﾄﾞの戻り値
			254 : 指定時間内にキー入力なし
			255 : パラメータの誤り
	  例)BU KEYWAIT 10 KEYNUM
	     BU KEYWAIT 60 @KEYYESNO Sure?(Y/N)

 *	KEYNUM [表示メッセージ]	 	(入力キーを標準出力にエコー)
 *	@KEYNUM [表示メッセージ]	(入力キーのエコーなし)
	  0〜9 のキー入力を待つ
		Ret= 0〜9   : 押された数字キー
	  例)BU KEYNUM 0〜9を押してください

 *	KEYYESNO [表示メッセージ]	(入力キーを標準出力にエコー)
 *	@KEYYESNO [表示メッセージ]	(入力キーのエコーなし)
	  Y,N のキー入力を待つ(Y=Y,y,ﾝ,Ｙ,ｙ  N=N,n,ﾐ,Ｎ,ｎ)
		Ret=	  0 : Y
			  1 : N
	  例)BU KEYYESNO 宜しいですか? (Y/N)

 *	KEYRETSPC [表示メッセージ]
	  リターンかスペースキーの入力を待つ
		Ret=	  0 : リターン
			  1 : スペース

 *	KEYESCANY [表示メッセージ]
	  [ESC]かそれ以外のキーの入力を待つ
		Ret=	  0 : [ESC]
			  1 : それ以外

 *	KEYCODE [表示メッセージ]	(入力キーを標準出力にエコー)
 *	@KEYCODE [表示メッセージ]	(入力キーのエコーなし)
	  キー入力を待つ
		Ret= 0〜255 : 入力したキーコード
	  例)BU KEYCODE 何かキーを押してください

 *	KEYLIST KEY_LIST [表示メッセージ]	(入力キーを標準出力にエコー)
 *	@KEYLIST KEY_LIST [表示メッセージ]	(入力キーのエコーなし)
	  KEY_LISTに指定されたキーが入力されるまで待つ
	  KEY_LISTに指定されたキーが押されると左からの順番(1,2,3...)をリ
	  ターンとして返します. 例えば BU KEYLIST ABCD の指定で C が押
	  されるとリターンとして 3 が返ります. KEY_LIST内と入力された文
	  字は共に英大小文字は同一視されます(aもAも同じとして扱われます)
	  また文字コード自身を\x??の形式で指定することもできます.
		Ret= 1〜254 : KEY_LIST中の左からの順番
			255 : パラメータの誤り(KEY_LISTが指定されなかった)
	  例)BU KEYLIST 0123456789ABCDEF 16進数で入力してください:
	     BU @KEYLIST \x0D\x1B リターンまたはESCを押してください

 *	KEYBUFF
	  キーバッファの状態を調べる
		Ret=	  0 : 入力文字なし
			  1 : 入力文字あり

 *	KEYCLEAR
	  キーバッファのクリア
		Ret=	  0

 *	LINEINPUT [表示メッセージ]	(入力キーを標準出力にエコー)
 *	@LINEINPUT [表示メッセージ]	(入力キーのエコーなし)
	  リターンキーを押すまで入力し標準出力に表示する(128文字まで)
		Ret= 0〜128 : 入力した文字数
	  例)BU -nPASSWD LINEINPUT PASSWORD:	→環境変数PASSWDに文字列を代入
	     ECHO|BU -nEMODE @LINEINPUT		→ECHOの状態を示す文字列を代入

 *	LINEINPUTN n [表示メッセージ]	(入力キーを標準出力にエコー)
 *	@LINEINPUTN n [表示メッセージ]	(入力キーのエコーなし)
	  リターンキーを押すまで入力し標準出力に表示する(n文字まで)
		Ret= 0〜128 : 入力した文字数
	  例)BU -nPASSWD LINEINPUTN 8 PASSWORD:	→環境変数PASSWDに文字列を代入

 !	SHIFTKEY	[SHIFT]
 !	CTRLKEY		[CTRL]
 !	GRAPHKEY	[GRPH]/[GRAPH]		(PC98,FM16βのみ)
 !	ALTKEY		[ALT]/[Alt]/[GRPH]	(ALTはFMR,IBMのみ GRPHは98)
 !	KANAKEY		[ｶﾅ]
 !	CAPKEY		[CAP]
	  各キーの状態を得る
		Ret=	  0 : 離してる(OFFになっている)
			  1 : 押してる(ONになっている)
			255 : 機械を未サポート

 *	DSKREADY [d:]
	  ドライブの状態を得る(ドライブ省略時はカレントドライブ)
		Ret=	  0 : 使用可能
			  1 : リード/ライトエラー
			  9 : ライトプロテクトされている
			 10 : ドライブの準備ができてない
			 11 : ユニットが存在しない
	  例)BU DSKREADY C:

 *	CHKDSKSIZE [n [d:]]
	  ドライブの全容量を調べる(ドライブ省略時はカレントドライブ)
	  指定の数値をキロバイトとみなしてそれ以上容量があるかを返します
	  n=0〜65535(Kbytes)(省略時は100)
		Ret=	  0 : 容量がある
			  1 : 容量がない
			255 : ディスクのエラー
	  例)BU CHKDSKSIZE 300 C:

 *	CHKDSKFREE [n [d:]]
	  ドライブの空き容量を調べる(ドライブ省略時はカレントドライブ)
	  指定の数値をキロバイトとみなしてそれ以上空きがあるかを返します
	  n=0〜65535(Kbytes)(省略時は100)
		Ret=	  0 : 空きがある
			  1 : 空きがない
			255 : ディスクのエラー

 *	DSPDSKSIZE [d:]
	  ドライブの全容量を標準出力に表示(ドライブ省略時はカレントドライブ)
	  数値はキロバイト単位
		Ret=	  0 : OK
			255 : ディスクのエラー

 *	DSPDSKFREE [d:]
	  ドライブの空き容量を標準出力に表示(ドライブ省略時はカレントドライブ)
	  数値はキロバイト単位
		Ret=	  0 : OK
			255 : ディスクのエラー

 *	CURDRV [d:]     (ドライブ[d:],d:を指定するとd:をそのまま表示する)
 *	CURPATH [d:]    (パス[\path])
 *	CURDRVPATH [d:] (ドライブ+パス[d:\path])
 *	CURPATH1 [d:]   (パス[\path\])
 *	CURDRVPATH1 [d:](ドライブ+パス[d:\path\])
	  d:ドライブのドライブ／パスを標準出力表示(x:省略時はカレントドライブ)
	  CURPATH1,CURDRVPATH1は末尾が必ず'\'になるようにする
		Ret=	  0

 *	GETDRV
	  カレントドライブ番号を返す
		Ret= ドライブ番号(A=0,B=1...)

 *	CDD [d:][\path]
	  指定のドライブに移動しカレントディレクトリを\pathに変更
		Ret=	  0 : OK
			  1 : d:に移動できない/\pathがない
			255 : エラー(d:\pathがまったく指定されなかった)

 *	XCDD [d:][\path]
	  カレントドライブを待避し d:に移動後 カレントディレクトリを待避し,デ
	  ィレクトリを \pathに移す
	  待避は環境変数 XCDDTMPに行う
	  待避は一つしか行なえないので注意(2回目は1回目のが消える)
	  PUSHDとは移動先ドライブのディレクトリを保存する点が異なる
		Ret=	  0 : OK
			  1 : d:に移動できない/\pathがない

 *	XPOP
	  XCDDで待避した環境変数 XCDDTMPを元に ドライブ,ディレクトリを移動
		Ret=	  0 : OK
			  1 : d:に移動できない/\pathがない/XCDDTMPがない

 *	PUSHD [d:][\path]
	  カレントドライブとディレクトリを待避後,ディレクトリを d:\path に移す
	  待避は環境変数 PUSHDTMPに行う
	  複数の待避を行なう事ができる
	  XCDDとは移動元ドライブのディレクトリを保存する点が異なる
		Ret=	  0 : OK
			  1 : d:に移動できない/\pathがない

 *	POPD
	  PUSHDで待避した環境変数 PUSHDTMPを元に ドライブ,ディレクトリを移動
		Ret=	  0 : OK
			  1 : d:に移動できない/\pathがない/PUSHDTMPがない

 !	DSPDRV media [unit] [partition]		(98,FMのみ)
	  指定ドライブ(メディア)のドライブ名を表示する.
		Ret=  0〜15 : ドライブ番号(A=0,B=1...)
			253 : ドライブが存在しない
			254 : パラメータの誤り
			255 : 機械を未サポート
	  mediaには以下の指定ができます.
		FD	: 1MB フロッピーディスク
		SD	: 320KB フロッピーディスク
		HD	: ハードディスク(SCSI,SASI)
		RAM	: RAMディスクまたは最終接続の後のドライブ
	  unit,partitionはユニット番号とパーテーション(区画)番号を指定します.
	  unitを省略時には0, パーテーション番号を省略時には1 になります.
	  注意: PC98とFMのみで使用できます.
	  (PC98ではパーテーション番号は指定できません, またSCSIとSASIなどが
	   混在していると値が正常に返りません)
	  例)BU DSPDRV FD 1
	     BU -nRAM DSPDRV RAM

 *	CHKMEMSIZE [n]
	  メモリの全容量を調べる
	  指定の数値をキロバイトとみなしてそれ以上容量があるかを返します
	  n=0〜65534(Kbytes)(省略時は100)
		Ret=	  0 : 容量がある
			  1 : 容量がない

 *	CHKMEMFREE [n]
	  メモリの空き容量を調べる
	  指定の数値をキロバイトとみなしてそれ以上空きがあるかを返します
	  n=0〜65534(Kbytes)(省略時は100)
		Ret=	  0 : 空きがある
			  1 : 空きがない

 *	CHKMEMSIZE 65535
 *	CHKMEMFREE 65535
	  BU.COMのバージョンを得る.なお BU.COM 1.05c以前では無効(1が返る)
	  です. 数値には 1.06 なら 106 が返ります. 1.06a などの数値の下の
	  英文字のバージョン文字は無視されます.
		Ret= バージョンを表す数値
			  1 : 無効
	  例)BU CHKMEMSIZE 65535

 *	DSPMEMSIZE
	  メモリの全容量を標準出力に表示
	  数値はキロバイト単位
		Ret=	  0

 *	DSPMEMFREE
	  メモリの空き容量を標準出力に表示
	  数値はキロバイト単位
		Ret=	  0

 *	LABEL [d:][name]
	  ボリュームラベルの表示,比較
	  d:ドライブ(省略時はカレント)のボリュームラベルを表示します.
	  nameを付けるとボリュームラベルと比較して結果を返します. nameには
	  ワイルドカードが使用可能です.
		Ret=	  0 : ラベルとnameが同じ,ラベルを正常表示
			  1 : ラベルとnameが違う
			255 : ボリュームラベルが無い,エラー
	  例)BU LABEL A:WORKDISK*

 *	VOLUMESERIAL [d:][num-num]
	  ボリュームシリアル番号の表示, 比較 (DOS 4.0以降のみで使用可能)
	  d:ドライブ(省略時はカレント)のボリュームシリアル番号を16進数の
	  XXXX-XXXXの形式で表示します. num-numを付けるとディスクのボリュ
	  ームシリアル番号と比較して結果を返します.
		Ret=	  0 : シリアルとnum-numが同じ,シリアルを正常表示
			  1 : シリアルとnum-numが違う
			255 : シリアル番号がない, エラー
	  例)BU VOLUMESERIAL A:1234-ABCD

 *	TIMESTAMP file1 file2
	  2つのファイルのタイムスタンプを比較
		Ret=	  0 : 同じ
			  1 : file1 の方が新しい
			  2 : file2 の方が新しい
			 10 : file1 が見つからない
			 20 : file2 が見つからない
			 50 : file1 アクセスエラー
			 60 : file2 アクセスエラー
			255 : エラー(ファイルが２つ指定されなかった)
	  例)BU TIMESTAMP A:FILENAME.DOC C:FILENAME.DOC

 *	UPDATE file1 file2
	  2つのファイルのタイムスタンプを比較して更新
	  file1の方が新しいか, file2が無ければCOPYコマンドを実行する(パ
	  ラメータはfile1,file2をそのまま渡します)
		Ret=	  0 : 同じ
			  1 : 更新完了(file1 の方が新しい)
			  2 : file2 の方が新しい
			 10 : file1 が見つからない
			 20 : 更新完了(file2 が見つからない)
			 50 : file1 アクセスエラー
			 60 : file2 アクセスエラー
			255 : エラー(ファイルが２つ指定されなかった,更新エラー)
	  例)BU UPDATE A:FILENAME.DOC C:FILENAME.DOC

 *	FILESIZE name [B][M] [n]
	  nameファイルの容量をキロバイト単位で返す.[B]を指定するとバイト単位
	  [M]を指定するとメガバイト単位での処理となる.
	  (1Kbyte=1024bytes , 1Mbytes=1024Kbytes)
		Ret= 0〜253 : nなし ファイルの容量
			254 : nなし ファイルの容量が254以上
			255 : ファイルがない,エラー
	  nを指定するとファイルサイズを比較して結果を返す.
	  n=0〜65535(単位はKbyte,[B]:byteまたは[M]:Mega Byte)
		Ret=	  0 : nより小さい
			  1 : nと等しい
			  2 : nより大きい
			255 : ファイルがない,エラー
	  例)BU FILESIZE test.com
	     BU FILESIZE test.com B 128

 *	FILECOUNT [d:][name]
	  d:ドライブ(省略時はカレント)のnameにマッチする(省略時は全ファイル)
	  のファイル数(ボリューム,サブディレクトリ除く)を返す
	  nameにはワイルドカード(*,?)が使えます. ディレクトリ内の検索のとき
	  は \bin\*.* のようにワイルドカードを含めて指定してください.
		Ret= 0〜253 : ファイル数
			254 : ファイル数が254以上
			255 : エラー,ファイルなし

 *	LINPUTFILE name [n]
	  ファイルの指定行を標準出力. 行数:n=1〜65535(省略時は1)
		Ret=	  0 : 正常終了
			254 : 指定の行が見つからない
			255 : ファイルがない,エラー
	  例)BU LINPUTFILE BU.HLP 9

 *	GETFATR name
	  ファイルの属性を得る
		Ret=  0〜31 : ファイル属性
			255 : ファイルがない,エラー
	  なおDOSのファイルの属性は次の様になっていて複数の属性を有効にで
	  きますので使用時はビット単位で属性を得るようにしてください.
		 0:ノーマル		(BIT 0)
		 1:リードオンリー	(BIT 1)
		 2:隠し(Hidden)		(BIT 2)
		 4:システム		(BIT 3)
		 8:ラベル		(BIT 4)
		16:ディレクトリ		(BIT 5)

 *	FILECRC name [n]
	  ファイルのCRC(16BITの16進数)値を標準出力.
		Ret=	  0 : 正常終了
			255 : ファイルがない,エラー
	  nを指定するとファイルのCRCを検査 .n=0〜FFFF(16進数)
		Ret=	  0 : CRC値が一致した
			  1 : CRC値が異なる
			255 : ファイルがない,エラー
	  例)BU -nCRC FILECRC COMMAND.COM	→環境変数CRCにCRC値を代入
	     BU FILECRC COMMAND.COM %CRC%	→環境変数CRCと比較

 *	FILELINE name [n]
	  ファイルの行数を返す.
		Ret= 0〜253 : ファイルの行数
			254 : ファイルの行数が254以上
			255 : ファイルがない,エラー
	  [n]を指定するとファイルの行数をnと比較. n=0〜65535
		Ret=	  0 : nより小さい
			  1 : nと等しい
			  2 : nより大きい
			255 : ファイルがない,エラー
	  例)BU FILELINE TEST.TXT
	     BU FILELINE TEST.TXT 128

 *	TEMPNAME [n:\dir]
	  一時ファイル名を標準出力
	  DOSと同じ形式で一時ファイル名を取得して表示します. n:\dir には
	  作成するパス名を指定してください. (存在しないディレクトリを指定
	  するとエラーになります). 指定がなければカレントが想定されます.
	  表示は n:\dir を含めた形で行われます. (例: C:\TMP\142D3500)
	  なお複数の一時ファイル名を1度に得ないようにしてください.(ファイ
	  ルが存在しなければ同名のファイルが出力される場合があります)
	  一時ファイル名は表示されるだけで実際には作成を行いません.
		Ret=	  0 : 正常終了
			255 : エラー
	  例)BU -nFNAME TEMPNAME C:\TMP		→C:\TMPに作れる一時ファイル名
						  を FNAME に代入

 *	PARSEFILE str
	  strがファイル名として使用可能かをチェック
	  文字列中にファイル名として使用できない文字(+<|>)などがあるかを返す.
		Ret=	  0 : 使用可能
			  1 : ワイルドカード文字が含まれる
			  2 : 使用できない文字が含まれる
			255 : パラメータエラー
	  例)BU PARSEFILE "%INPUT%"	→%INPUT%内の文字列をチェック

 *	WHICH file[.ext]		(ファイル名の表示あり)
 *	@WHICH file[.ext]		(ファイル名の表示なし)
	  PATHの中からfileを探して表示する.
	  拡張子(.ext)を指定すると指定の拡張子のものだけを検索し, 指定
	  しなければ .COM .EXE .BAT の順に検索する. 始めに一致したファイル
	  だけをフルパス(X:\PATH\FILENAME.EXT)で表示する.
	  @WHICHは一致したファイルの表示を行なわない.
		Ret=	  0 : 一致するファイルが合った
			  1 : 一致するファイルがなかった
			  2 : PATHの指定がないもしくは設定がおかしい
			255 : パラメータエラー
	  例)BU WHICH MORE
	  例)BU WHICH LINK.EXE

 *	WHICH2 file[.ext]		(ファイル名の表示あり)
 *	@WHICH2 file[.ext]		(ファイル名の表示なし)
	  カレント及びPATHの中からfileを探して表示する.
	  拡張子(.ext)を指定すると指定の拡張子のものだけを検索し, 指定
	  しなければ .COM .EXE .BAT の順に検索する. 始めに一致したファイル
	  だけをフルパス(X:\PATH\FILENAME.EXT)で表示する.
	  @WHICH2は一致したファイルの表示を行なわない.
		Ret=	  0 : 一致するファイルが合った
			  1 : 一致するファイルがなかった
			  2 : PATHの指定がないもしくは設定がおかしい
			255 : パラメータエラー
	  例)BU WHICH2 MORE
	  例)BU WHICH2 LINK.EXE

 *	STRTOKDRV string	ドライブ+コロン		D:
 *	STRTOKDRV1 string	ドライブ		D
 *	STRTOKPATHNAME string	ドライブ以外		\PATH\NODE.EXT
 *	STRTOKPATH string	\パス			\PATH
 *	STRTOKPATH2 string	\パス\			\PATH\
 *	STRTOKNAME string	ファイル名		NODE.EXT
 *	STRTOKNODE string	\ノード			\NODE
 *	STRTOKNODE1 string	ノード			NODE
 *	STRTOKEXT string	拡張子			EXT
 *	STRTOKEXT2 string	.拡張子			.EXT
	  stringからそれぞれの部分を抽出し表示する(上記コマンドの右端は
	  "D:\PATH\NODE.EXT" を与えたときの表示)
		Ret=	  0 : 抽出できた
			  1 : 見つけられなかった
	  例)BU STRTOKDRV d:\path\file.ext	→d: が表示される
	     BU STRTOKPATH d:\path\test.ext	→\path が表示される

 *	STRUPR string		大文字に変換
 *	STRLWR string		小文字に変換
	  文字列を大文字／小文字に変換して標準出力に表示
		Ret=	  0

 *	STRLEN string
	  文字列の長さを返す(文字列は[CR]までを長さとする)
		Ret= 0〜253 : 文字列の長さ
			254 : 文字列の長さが254以上
			255 : Reserved

 *	STRLEFT string [,n]
	  文字列の左側から抜き出して表示する
	  n=抜き出す文字数(1〜255,省略時は全文字列)
		Ret= 0〜253 : 表示文字列の長さ
			254 : 表示文字列の長さが254以上
			255 : Reserved
	  例)BU STRLEFT ABCDEF,2		("AB"が表示される)

 *	STRMID string [,n1,[n2]]
	  文字列を抜き出して表示する
	  n1=開始文字位置(1〜255,省略時は1)
	  n2=表示文字数(1〜255,省略時は255)
		Ret= 0〜253 : 表示文字列の長さ
			254 : 表示文字列の長さが254以上
			255 : Reserved
	  例)BU STRMID ABCDEF,2,3		("BCD"が表示される)

 *	STRRIGHT string [,n]
	  文字列の右側から抜き出して表示する
	  n=抜き出す文字数(1〜255,省略時は文字列の長さ)
		Ret= 0〜253 : 表示文字列の長さ
			254 : 表示文字列の長さが254以上
			255 : Reserved
	  例)BU STRRIGHT ABCDEF,2		("EF"が表示される)

 *	STRCMP str1 str2	文字列の比較
 *	STRNCMP str1 str2 nom	最大文字数指定で文字列を比較
 *	STRICMP str1 str2	英大小区別なしで文字列を比較
 *	STRCMPI str1 str2		〃
 *	STRNICMP str1 str2 nom	文字数指定,大小区別なしで文字列を比較
 *	STRNCMPI str1 str2 nom		〃
	  文字列の比較をして結果を返す.
		Ret=	  0 : 文字列が等しい
			  1 : 文字列が等しくない
	  例)BU STRNICMP "%1" "test" 4

 *	STRCHR2 str chr [n1,[n2]]
	  文字列から指定文字を検索して表示
	  str:文字列 chr:検索文字 n1:スキップする検索文字数(ﾃﾞﾌｫﾙﾄ 0)
	  n2:表示を行うn1からの検索文字数(ﾃﾞﾌｫﾙﾄ 1)
	  文字列よりchrの文字を探しn1番目の位置からn2個見つかったところまでを
	  表示します.(chrは1バイトで表せる範囲)
	  chrには文字自身または, \x??の形式の16進数で指定できます.
		Ret= 0〜253 : 表示した文字列の長さ
			254 : 文字列の長さが254以上
			255 : エラー
	  例)BU STRCHR2 c:\bin;c:\bat;c:\tool ;		(c:\bin を表示)
	     BU STRCHR2 c:\bin;c:\bat;c:\tool ; 1 2	(c:\bat;c:\tool を表示)
	     BU STRCHR2 "WS12 9.1.2.8" \x20 1 1		(9.1.2.8 を表示)

 *	STRDEL2QUOTE str
	  文字列からダブルクォーテーション["]をすべて取り除いて表示
	  処理対象の文字列に["]が含まれているときの前処理等に使ってください.
		Ret= 0〜255 : 処理したダブルクォーテーションの数
	  例)BU STRDEL2QUOTE -nNEWFOO %OLDFOO%

 *	STRDELSPC str
	  文字列の先頭及び末尾のスペース文字を取り除いて表示
		Ret= 0〜255 : 表示した文字数
	  例)BU STRDELSPC -nENV "%INPUTENV%"

 *	ADDBACKSLASH str
	  文字列をそのまま表示しますが,文字列の最後がバックスラッシュ(\)
	  と違えば付加して表示します
		Ret=	  0 : 付加しない
		Ret=	  1 : 付加した
	  例)BU ADDBACKSLASH A:\BIN			(A:\BIN\ が表示される)

 *	DELBACKSLASH str
	  文字列をそのまま表示しますが,文字列の最後がバックスラッシュ(\)
	  であれば削除して表示します
		Ret=	  0 : 削除しない
		Ret=	  1 : 削除した
	  例)BU DELBACKSLASH A:\BIN\			(A:\BIN が表示される)

 !	MACHINE
	  機械名を得る
		Ret=	150 : AX
			160 : IBM (PC-AT)
			170 : Toshiba J-3100
			180 : NEC PC98(Hireso)
			185 : NEC PC98(Normal)
			190 : Fujitsu FM 24dot
			195 : Fujitsu FM 16dot
			198 : Fujitsu OASYS
			199 : Fujitsu FM16B
			255 : 機械を未サポート

 !	MACHINE2
	  機械名を得る
	  MACHINEとはマシン名をビット単位で返す点が異なります.
		Ret= ビット単位でマシンの判別値(00ならマシンを未サポート)
			BIT7:	Reserve
			BIT6:	1:IBM系			(40h)
			BIT5:	1:PC98系		(20h)
			BIT4:	1:FMR/FM16B/OASYS系	(10h)
			BIT3:	Reserve
			BIT2:	---+
			BIT1:	   +-- (機種別に使用)
			BIT0:	---+
		    FMR系(BIT4が1の時)
			    BIT2:			1:OASYS
			    BIT1:			1:FM16B
			    BIT0:	0:16DOT		1:24DOT
		    PC98系(BIT5が1の時)
			    BIT2:
			    BIT1:
			    BIT0:	0:Normal	1:Hireso
		    IBM系(BIT6が1の時)
			    BIT2:   -+	BIT0が1の時
			    BIT1:   -+		00:AX  01:J3100
			    BIT0:	0:PC/AT		1:not PC/AT

 *	SETERRORLEVEL n
	  ERRORLEVELを指定値にセットする(n=0〜255)
		Ret=	  n : OK
			255 : nが255,数値がエラー

 *	DSPERRORLEVEL
	  BU起動時に(COMMAND.COM内に)保持していたERRORLEVELを標準出力に表示
	  親プロセスがCOMMAND.COMで無ければ正しく表示しないので注意
		Ret=	  ? : 表示したのと同じERRORLEVEL
			255 : ERRORLEVELが255,親プロセスが異常

 *	RUN [ﾌﾟﾛｸﾞﾗﾑ名 [& ﾌﾟﾛｸﾞﾗﾑ名]]
	  &で区切られたプログラム(.COM .EXE .BAT)を連続して実行する
	  環境変数<COMSPEC>(通常 COMMAND.COM)を経由して実行している.
	  ﾌﾟﾛｸﾞﾗﾑの指定がなければプロンプトになり EXITで戻る(COMMAND.COM時)
	  COMMAND.COM内部コマンドも使用可能.
	  '&'自身の指定には"\&"を使用してください
		Ret=	  0 : <COMSPEC>の動作完了
			255 : <COMSPEC>がない,メモリーの異常
	  例)BU RUN CHKDSK C: & CHKDSK D:

 *	TIMEWAIT [n]
	  n秒間待つ(n=1〜65535,ﾃﾞﾌｫﾙﾄ 3)
	  なお, 正確な秒数を計っているのではなく, DOSの秒の変わるタイミング
	  を1秒としています.
		Ret=	  0
	  例)BU TIMEWAIT 3

 *	GETENVSIZE
	  環境の全サイズ(パラグラフ:16バイトが1パラグラフ)を得る
		Ret= 0〜253 : 環境のサイズ(パラグラフ)
			254 : 環境のサイズが254以上
			255 : Reserved

 *	GETENVFREE
	  環境の残りサイズ(パラグラフ:16バイトが1パラグラフ)を得る
		Ret= 0〜253 : 環境の残りサイズ(パラグラフ)
			254 : 環境の残りサイズが254以上
			255 : Reserved

 *	DSPENVSEGMENT
	  BUが参照する環境のセグメントを16進数で表示する
		Ret=	  0

 *	GETDOSVER
	  MS-DOSのバージョンを得る. MS-DOSが 3.10 なら 31 が返ります.
	  小数点の1桁目以降は無視されます.(3.21なら 32 が返ります)
		Ret= MS-DOSバージョン番号

 *	DSPBATDRV	(ドライブ[d:])
 *	DSPBATDRVPATH	(ドライブ+パス[d:\,d:\path])
 *	DSPBATFULLNAME	(ドライブ+パス+ファイル名[d:\path\batfile.bat])
	  現在実行しているバッチファイルのドライブ,パス名などを標準出力表示
	  BATCPで.COMにしたバッチファイル内でBUの取り込みなしで動作させ
	  ると正常動作をしません(実行時のカレントパスになります).
	  BATCP V1.30以上のバージョンで/Vを付けて取り込むようにしてください
	  (この場合.COMのファイル名を表示します).
		Ret=	  0 : 正常終了
			255 : エラー(バッチファイル内で実行されなかった)

 *	BEEP [n]
	  指定した回数ビープを鳴らす.n=0〜65535(省略時は1)
	  nに 0を指定するとキー入力が有るまで鳴らし続ける
		Ret=	  0

 *	PEEK [W] seg off
	  指定アドレスの値を得る(seg,offは16進)
	  [W]を付けるとワードで入力.デフォルトはバイト.
		Ret= 0〜255 : 値
	  例)BU PEEK A000 F00		(A000:0F00の値を得る)
	
 *	POKE [W] seg off nom
	  指定アドレスに値を設定する(seg,off,numは16進)
	  [W]を付けるとワードで設定.デフォルトはバイト.
		Ret= 0〜255 : 値
	  例)BU PEEK A000 F00 32	(A000:0F00に32を設定)

 *	INPORT [W] port
	  指定IOポートの値を得る(portは16進)
	  [W]を付けるとワードで入力.デフォルトはバイト.
		Ret= 0〜255 : 値
	  例)BU INPORT 1E0		(ポート1E0の値を得る)

 *	OUTPORT [W] port nom
	  指定IOポートに値を設定(port,numは16進)
	  [W]を付けるとワードで出力.デフォルトはバイト.
		Ret= 0〜255 : 値
	  例)BU OUTPORT 37 6		(ポート37に6を設定)

 *	INT num [AH,AL,BH,BL,CH,CL,DH,DL]
	  8086割り込みを実行する. 値はすべて16進のbyteまたは 1文字('x')
	  AH以下は任意の場所で省略可
		Ret= 0〜255 : 返された ALの値
	  例)BU INT 21 54		(ベリファイの状態がRetに返る)
	     BU INT 21 2 0 0 0 0 0 0 'A'(Aを画面出力)

 *	INT num [AH=xx AL=xx | AX=xxxx BX=xxxx...] [R=reg]
	  8086割り込みを実行する(レジスタで数値を指定). 値はすべて16進
	  または文字('x'). R=reg(regにはレジスター名を指定)を指定すると
	  Ret(リターンコード)に指定したレジスターの値が返ります.
		Ret= 0〜255 : 返された AL(または指定したレジスター)の値
	  例)BU INT 21 ax=3801 dx=ffff	(国別情報をUSAにする)
	     BU INT 21 ah=2c r=dh	(リターンに現在時刻の'秒'が返る)

 *	MOVEDATA srcseg srcoff destseg destoff size
	  メモリ領域のコピー. すべて16進数のword. (sizeは16進数のバイト数)
	  移動元と移動先が重なっていても構わない.
		Ret=	  0
	  例)BU MOVEDATA A000 0 A000 50 1000
